sgrep() {
  grep "$@" | grep -v .svn
}

up() {
  local x='';
  for i in $(seq ${1:-1});
    do x="$x../";
  done;
  cd $x;
}

diff_brief() {
  /usr/bin/diff --brief -r "$1" "$2" | sed 's/^Files /diff /' | sed 's/ and / /' | sed 's/ differ$//'
}

qapwd() { 
    if [[ -z "$1" ]]; then echo 'usage: qapwd trichqa';  return; fi
    ldapsearch -LLL -x -H ldaps://ds3.apidb.org \
      -D "uid=mheiges,ou=People,dc=apidb,dc=org" -W \
      -b "uid=$1,ou=People,dc=apidb,dc=org" \
      -s base \
      userPassword \
      | perl -p0e 's/\n //g' \
      | grep userPassword \
      | sed 's/userPassword:: //' \
      | openssl base64 -d \
      | sed 's/{CLEAR}//' 
}


lastsession() { 
  if [[ -z "$1" ]]; then echo 'usage: lastsession password instancename';  return; fi
  if [[ -z "$2" ]]; then echo 'usage: lastsession password instancename';  return; fi
  pw=$1
  instance=$2
  sqlplus -S system/$pw@$instance < \
    <(echo "select username,  \
            to_char(sysdate - last_call_et / 86400,'YYYY-MM-DD HH24:MI') \
            from v\$session where username is not null \
            and username not in ('DBSNMP', 'SYSTEM');")
}

# manage dot files;
# based on https://news.ycombinator.com/item?id=11071754
dotf() {
  git --git-dir=$HOME/.dotfiles.git/ --work-tree=$HOME "$@"
}

check_uncommitted_dotfiles() {
  mod_dotfiles="$(dotf ls-files -m)"
  if [[ -n $mod_dotfiles ]]; then
    echo -e " \x1B[1mYou have uncommitted dot files.\x1B[0m Run"
    echo -n "dotf commit"
    for i in $mod_dotfiles; do
      echo -n " $i"
    done
    echo
  fi
}

check_unpushed_dotfiles() {
  mod_dotfiles="$(dotf diff HEAD origin/master --name-only)"
  if [[ -n $mod_dotfiles ]]; then
    echo -e " \x1B[1mYou have locally committed dot files not yet pushed.\x1B[0m Run"
    echo "dotf push"
  fi
}

check_unmerged_dotfiles() {
  dotf fetch
  dotf checkout | sed 's/Your branch is/Your dotfiles are/' | sed 's/git/dotf/'
}

# print file without #-delimited comments
decomment() {
  grep -v '^\W*#' $1 | egrep -v '^\W*$'
}

ot() {
  open -a Terminal "`pwd`"
}


function nginxerrbyip () {
  # grep Nginx logs for errors for given IP address, optional
  # date timestamp
  IP=$1
  DATE=$2
  find /var/log/nginx/ -maxdepth 2 -name access_log 2> >(grep -v 'Permission denied' >&2) | \
    xargs ack ${IP} | \
    egrep ' 500 | 404 ' | \
    grep "${DATE}"
}

function nginxbyip () {
  # grep Nginx logs for given IP address, optional
  # date timestamp
  IP=$1
  DATE=$2
  find /var/log/nginx/ -maxdepth 2 -name access_log 2> >(grep -v 'Permission denied' >&2) | \
    xargs ack ${IP} | \
    grep "${DATE}"
}

function packerssh() {
  if [[ ! $2 =~ ^[0-9]+$ ]]; then
    echo "SSH to in-flight Packer build. Usage: packerssh <user> <port>"
    echo "where <port> can be found in Packer stdout line:"
    echo "Creating forwarded port mapping for communicator (SSH, WinRM, etc) (host port 4355)"
    return 1
  fi
  cmd="ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no \
     -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no \
     $1@localhost -p $2"
  echo $cmd
  $cmd
}

# mimic GNU md5sum. Extra space is injected between hash and filename to
# match GNU's text mode output (vs. binary mode indicated with a '*' in
# the second position)
function md5sum() {
  md5 -r "$@" | sed 's/ /  /'
}; alias md5=md5sum

# iTerm2 cd to selected dir (or parent dir if selected file).
# Configure iTerm:
#     Preferences -> Keys -> Key Mappings
#       Paste from selection
#         Replace selection: ^(~[^\/]*\/)?(.*)$
#         With: iterm_cd_to_selected_dir "$1" $2\r
#
# Note not quoting $2 so spaces and escaped spaces are handled.
#
# Splitting path allows for tilde expansion by shell.
#  ~mheiges/"Vagrant"
#  ~/"Vagrant"
#  "/Users/mheiges/Vagrant"
#
# cd $1"$2" && pwd\r
function iterm_cd_to_selected_dir() {
  local prefix="$1"
  shift
  local suffix="$@"
  local path="${prefix}${suffix}"
  if [[ -f "$path" ]]; then
    cd "$(dirname "$path")" && pwd
  else
    cd "$path" && pwd
  fi
}

# print modulus checksums for SSL certs, keys, CSR
# (for confirming cert and key matching)
function ssl-pki-chk {
  for f in "$@"; do
    ext="${f##*.}"
    case $ext in
      'csr')
        type=req
        ;;
      'cer'|'crt')
        type=x509
        ;;
      'key')
        type=rsa
        ;;
      *)
        echo "Don't know about file extension for $f"
        continue
        ;;
    esac
    mod=$(openssl $type  -noout -modulus -in "$f" 2>/dev/null)
    if [[ $? -eq 0 ]]; then
      md5="$(echo $mod | openssl md5 | sed 's/(stdin)= //')"
      echo "$md5 $(basename "$f")"
    else
      echo "ERROR on $(basename "$f")"
    fi
  done
}



### CLEARLEAP ####
# https://wiki.clearleap.com/display/DevOps/AWS+SSH+Helper
function aws-default {
  export AWS_DEFAULT_PROFILE=$1
}
function ssh-aws {
  ssh -i ~/.ssh/aws_id_rsa admin@`aws-ip $1`
}
function aws-ip {
  aws ec2 describe-instances --output text --max-items 1 --filters "Name=tag:Name,Values=$1*" "Name=instance-state-name,Values=running" --query 'Reservations[*].Instances[*].PrivateIpAddress'
}
function aws-ip-all {
   aws ec2 describe-instances --filters "Name=tag:Name,Values=$1*" "Name=instance-state-name,Values=running" --query 'Reservations[*].Instances[*].[PrivateIpAddress,Tags[?Key==`Name`].Value[]]' --output text
}

# from Paul Travis (pers. Slack) (customized with some personal error handling)
function aws_search_name() {
  if [ -z $1 ]; then
    echo -e "Usage:\n  aws_search_name Name\n    where Name value matches EC2 instances Name tags"
  else
    aws ec2 describe-instances --output text | grep "^TAGS\s*Name.*$1" | awk '{print $3}' | sort |   uniq
  fi
}
function aws_ip_of() {
    IPS=$(aws ec2 describe-instances --output text --filters "Name=tag:Name,Values=$1*"              "Name=instance-state-name,Values=running" --query 'Reservations[*].Instances[*].PrivateIpAddress' |  tr '\n' ' ')
    NUM=$(echo $IPS | wc -w | tr -d '[[:space:]]')
    AS='{print $1}'
    if [ $NUM -ne 1 ]; then
        (>&2 echo "WARNING: Found $NUM instances with similar name: $IPS")
        if [ ! -z "$2" ] && [ "$NUM" -ge "$2" ]; then
            AS="{print \$$2}"
        fi
    fi
    echo $IPS | awk "$AS"
}
function ssh-aws() {
  #ptravis: ssh -i ~/.ssh/aws_id_rsa -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -q admin@`aws_ip_of $@`
  #mheiges: (opts pushed to ~/.ssh/config)
  ssh admin@`aws_ip_of $@`
}

# rsync puppet code from workstation to EC2, then fswatch workstation code and
# rsync changes. (This is not actually limited to puppet code.)
function pupsit() {
  usage="Usage: $(tput bold)pupsit <dir to watch> <remote dest dir> <dest host>$(tput sgr0)"
  [ $# -eq 0 ] && { echo "Run fswatch on given directory. $usage"; return; }
  local watchdir="$1"
  local destdir="$2"
  local desthost="$3"
  [ -z "$destdir" ] && { echo "dest dir not set. $usage"; return; }
  [ -d "$watchdir" ] || { echo "local directory not found. $usage"; return; }
  nc  -z -G1  "$desthost" 22 >/dev/null || { echo "port 22 not open on '$desthost'. $usage"; return; }
  run_rsync="rsync -avzP --delete --exclude=.git --exclude hiera/launchconfig.yml --exclude hiera/golden_image.yaml  $watchdir/ admin@$desthost:$destdir";
  echo "$(tput bold)$(tput setaf 2)initial rsync starting...$(tput sgr0)"
  $run_rsync && {
    echo -e "$(tput bold)$(tput setaf 2)\n--------\ninitial rsync finished\n"
    echo -e "now watching $(tput sgr0)'$watchdir'$(tput bold)$(tput setaf 2)...."
    echo -e "and pushing to $(tput sgr0)'$desthost@$destdir'$(tput bold)$(tput setaf 2)...."
    echo -e "$(tput bold)$(tput setaf 2)\n---------\n$(tput sgr0)$(tput setaf 4)"
    fswatch -o "$watchdir" | \
    while read f; do
      $run_rsync
    done
  }
}


### END CLEARLEAP ###
