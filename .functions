sgrep() {
  grep "$@" | grep -v .svn
}

up() {
  local x='';
  for i in $(seq ${1:-1});
    do x="$x../";
  done;
  cd $x;
}

diff_brief() {
  /usr/bin/diff --brief -r "$1" "$2" | sed 's/^Files /diff /' | sed 's/ and / /' | sed 's/ differ$//'
}

qapwd() { 
    if [[ -z "$1" ]]; then echo 'usage: qapwd trichqa';  return; fi
    ldapsearch -LLL -x -H ldaps://ds3.apidb.org \
      -D "uid=mheiges,ou=People,dc=apidb,dc=org" -W \
      -b "uid=$1,ou=People,dc=apidb,dc=org" \
      -s base \
      userPassword \
      | perl -p0e 's/\n //g' \
      | grep userPassword \
      | sed 's/userPassword:: //' \
      | openssl base64 -d \
      | sed 's/{CLEAR}//' 
}


lastsession() { 
  if [[ -z "$1" ]]; then echo 'usage: lastsession password instancename';  return; fi
  if [[ -z "$2" ]]; then echo 'usage: lastsession password instancename';  return; fi
  pw=$1
  instance=$2
  sqlplus -S system/$pw@$instance < \
    <(echo "select username,  \
            to_char(sysdate - last_call_et / 86400,'YYYY-MM-DD HH24:MI') \
            from v\$session where username is not null \
            and username not in ('DBSNMP', 'SYSTEM');")
}

# manage dot files;
# based on https://news.ycombinator.com/item?id=11071754
dotf() {
  git --git-dir=$HOME/.dotfiles.git/ --work-tree=$HOME "$@"
}

check_uncommitted_dotfiles() {
  mod_dotfiles="$(dotf ls-files -m)"
  if [[ -n $mod_dotfiles ]]; then
    echo -e " \x1B[1mYou have uncommitted dot files.\x1B[0m Run"
    echo -n "dotf commit"
    for i in $mod_dotfiles; do
      echo -n " $i"
    done
    echo
  fi
}

check_unpushed_dotfiles() {
  mod_dotfiles="$(dotf diff HEAD origin/master --name-only)"
  if [[ -n $mod_dotfiles ]]; then
    echo -e " \x1B[1mYou have locally committed dot files not yet pushed.\x1B[0m Run"
    echo "dotf push"
  fi
}

check_unmerged_dotfiles() {
  dotf fetch
  dotf checkout | sed 's/Your branch is/Your dotfiles are/' | sed 's/git/dotf/'
}

# print file without #-delimited comments
decomment() {
  grep -v '^\W*#' $1 | egrep -v '^\W*$'
}

ot() {
  open -a Terminal "`pwd`"
}


function nginxerrbyip () {
  # grep Nginx logs for errors for given IP address, optional
  # date timestamp
  IP=$1
  DATE=$2
  find /var/log/nginx/ -maxdepth 2 -name access_log 2> >(grep -v 'Permission denied' >&2) | \
    xargs ack ${IP} | \
    egrep ' 500 | 404 ' | \
    grep "${DATE}"
}

function nginxbyip () {
  # grep Nginx logs for given IP address, optional
  # date timestamp
  IP=$1
  DATE=$2
  find /var/log/nginx/ -maxdepth 2 -name access_log 2> >(grep -v 'Permission denied' >&2) | \
    xargs ack ${IP} | \
    grep "${DATE}"
}

function packerssh() {
  if [[ ! $2 =~ ^[0-9]+$ ]]; then
    echo "SSH to in-flight Packer build. Usage: packerssh <user> <port>"
    echo "where <port> can be found in Packer stdout line:"
    echo "Creating forwarded port mapping for communicator (SSH, WinRM, etc) (host port 4355)"
    return 1
  fi
  cmd="ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no \
     -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no \
     $1@localhost -p $2"
  echo $cmd
  $cmd
}

# mimic GNU md5sum. Extra space is injected between hash and filename to
# match GNU's text mode output (vs. binary mode indicated with a '*' in
# the second position)
function md5sum() {
  md5 -r "$@" | sed 's/ /  /'
}; alias md5=md5sum

### CLEARLEAP ####
# https://wiki.clearleap.com/display/DevOps/AWS+SSH+Helper
function aws-default {
  export AWS_DEFAULT_PROFILE=$1
}
function ssh-aws {
  ssh -i ~/.ssh/aws_id_rsa admin@`aws-ip $1`
}
function aws-ip {
  aws ec2 describe-instances --output text --max-items 1 --filters "Name=tag:Name,Values=$1*" "Name=instance-state-name,Values=running" --query 'Reservations[*].Instances[*].PrivateIpAddress'
}
function aws-ip-all {
   aws ec2 describe-instances --filters "Name=tag:Name,Values=$1*" "Name=instance-state-name,Values=running" --query 'Reservations[*].Instances[*].[PrivateIpAddress,Tags[?Key==`Name`].Value[]]' --output text
}

### END CLEARLEAP ###